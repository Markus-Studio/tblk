import { AbstractParseTreeVisitor } from 'antlr4ts/tree/AbstractParseTreeVisitor';
import { ParserRuleContext } from 'antlr4ts';
import { SourceNode } from 'source-map';
import { TBLKParserVisitor } from '../grammar/TBLKParserVisitor';
import { splitLeadingBlank } from './utils';
import { SymbolTable } from './symbols';
import * as Parser from '../grammar/TBLKParser';

export interface PartialInfo {
  path: string;
  name: string;
  uri: string; // Source uri.
}

export type CompilerOptions = {
  /**
   * The path to the source file, used to generate source map.
   */
  uri: string | null;
  /**
   * True if you want to generate source maps.
   */
  sourceMap: boolean;
  /**
   * The compilation mode.
   */
  mode: 'javascript' | 'iife' | 'partial';
  /**
   * True if you want to generate typescript modules.
   */
  typescript: boolean;
  /**
   * The partials to be imported not supported when targeting `iife`.
   */
  partials: PartialInfo[] | null;
};

type ControlFlowItem = 'for' | 'if';

export class Compiler extends AbstractParseTreeVisitor<SourceNode>
  implements TBLKParserVisitor<SourceNode> {
  /** Used to check the correctness of open-close control-flow nodes. */
  protected controlFlowStack: ControlFlowItem[] = [];
  private symbols = new SymbolTable<string, null>();
  private usedElse = true;
  private indentLevel = 0;

  constructor(readonly options: CompilerOptions) {
    super();
    if (this.options.mode === 'iife' && this.options.typescript) {
      throw new Error('Typescript is not supported in iife mode.');
    }

    if (
      this.options.mode === 'iife' &&
      this.options.partials &&
      this.options.partials.length
    ) {
      throw new Error('Third-party partials are not supported in iife mode.');
    }
  }

  get indention() {
    return this.indentLevel === 0 ? '' : '  '.repeat(this.indentLevel);
  }

  /** Checks the head of the control-flow stack, throws error when:
   * a) Stack is empty.
   * b) Stack's head is not equal to the `expected` argument.
   *
   * @param expected The control-flow node kind expected to be at the top of
   * the stack.
   */
  protected check(expected: ControlFlowItem) {
    const length = this.controlFlowStack.length;
    if (length === 0) {
      throw new SyntaxError('Control-flow stack underflow.');
    } else {
      const actual = this.controlFlowStack[length - 1];
      if (actual !== expected) {
        throw new SyntaxError(
          `Parse error: Expected '${expected}' as control-flow stack head found '${actual}'.`
        );
      }
    }
  }

  /**
   * Tries to pop from the control-flow stack, operation fails if `check()`
   * throws.
   *
   * @param expected The expected value of the control-flow stack's head.
   * @see Compiler#check
   */
  protected pop(expected: ControlFlowItem) {
    this.check(expected);
    this.controlFlowStack.pop();
  }

  defaultResult() {
    return new SourceNode();
  }

  aggregateResult(aggregate: SourceNode, nextResult: SourceNode) {
    aggregate.add(nextResult);
    return aggregate;
  }

  /** Create an import statement based on the compiler options. */
  importStatement(name: string, path: string, defaultImport: boolean = false) {
    const lhs = defaultImport ? name : `{ ${name} }`;
    return this.options.typescript
      ? `import ${lhs} from "${path}";\n`
      : `const ${lhs} = require("${path}");\n`;
  }

  /** Create a function argument based on the compiler options */
  functionArgument(name: string, type: string, defaultValue?: string) {
    const def = defaultValue ? ` = ${defaultValue}` : '';
    return this.options.typescript ? `${name}: ${type}${def}` : `${name}${def}`;
  }

  visitDocument(context: Parser.DocumentContext) {
    this.indentLevel++;

    const indent = this.indention;

    const body = [
      // tmp is used when we downlevel CoalesceExpressions.
      ...(this.options.typescript ? [] : [this.indention, 'let tmp;\n']),
      ...context.partial().map(c => this.visit(c)),
      ...context.row().map(c => this.visit(c)),
      indent,
      this.options.mode === 'partial' ? 'w.pop();\n' : 'w.flush();\n',
      indent + 'return w.result.trimRight();\n'
    ];

    if (this.controlFlowStack.length > 0) {
      throw new Error('Unterminated control-flow statement.');
    }

    const head = this.options.typescript
      ? 'export default function render'
      : 'module.exports = function render';

    switch (this.options.mode) {
      case 'iife':
        return new SourceNode(null, null, null, [
          '// TBLK AUTOGENERATED FILE, DO NOT MODIFY.\n',
          '(function (Writer) { return function render($) {',
          indent + 'const w = new Writer();\n',
          ...body,
          '}})'
        ]);
      case 'javascript':
        return new SourceNode(null, null, null, [
          '// TBLK AUTOGENERATED FILE, DO NOT MODIFY.\n',
          this.importStatement('Writer', 'tblk/dist/src/writer') + '\n',
          ...(this.options.partials || []).map(partial =>
            this.importStatement('$' + partial.name, partial.path, true)
          ),
          head + '(',
          this.functionArgument('$', 'Record<string, any>', '{}'),
          ') {\n',
          this.indention + 'const w = new Writer();\n',
          ...body,
          '}'
        ]);
      case 'partial':
        return new SourceNode(null, null, null, [
          '// TBLK AUTOGENERATED FILE, DO NOT MODIFY.\n',
          this.importStatement('Writer', 'tblk/dist/src/writer') + '\n',
          ...(this.options.partials || [])
            .filter(partial => partial.uri !== this.options.uri)
            .map(partial =>
              this.importStatement('$' + partial.name, partial.path, true)
            ),
          head,
          '(',
          this.functionArgument('$', 'Record<string, any>', '{}') + ', ',
          this.functionArgument('root', 'Record<string, any>', '{}') + ', ',
          this.functionArgument('w', 'Writer', 'new Writer()'),
          ') {\n',
          this.indention + '$.__proto__ = root;\n',
          this.indention + 'w.push();\n',
          ...body,
          '}'
        ]);
      default:
        throw new Error('Unknown compilation mode.');
    }
  }

  visitPartialBegin(context: Parser.PartialBeginContext) {
    const prevIndention = this.indention;
    this.indentLevel++;
    return this.text(context, [
      prevIndention,
      'function $',
      this.visit(context.identifier()),
      '(',
      this.functionArgument('$', 'Record<string, any>', '{}') + ', ',
      this.functionArgument('root', 'Record<string, any>', '{}') + ', ',
      this.functionArgument('w', 'Writer'),
      ') {\n',
      this.indention,
      '$.__proto__ = root;\n',
      this.indention,
      'w.push();\n'
    ]);
  }

  visitPartialEnd(context: Parser.PartialEndContext) {
    const prevIndention = this.indention;
    this.indentLevel--;
    return this.text(context, [
      prevIndention,
      'w.pop();\n',
      this.indention,
      '}\n'
    ]);
  }

  visitPartialUse(context: Parser.PartialUseContext) {
    return this.text(context, [
      this.indention,
      '$',
      this.visit(context.identifier()),
      '({',
      ...context.assignment().map(c => this.visit(c)),
      '}, $, w)\n'
    ]);
  }

  visitAssignment(context: Parser.AssignmentContext) {
    return this.text(context, [
      this.visit(context.identifier()),
      ':',
      this.visit(context.singleExpression()),
      ','
    ]);
  }

  visitRow(context: Parser.RowContext) {
    const segments = [...context.segment()];
    const sourceNode = this.text(context, []);
    let didWrote = false;

    if (segments.length === 0) {
      return this.text(context, [this.indention, 'w.brk();\n']);
    }

    if (isSpanSegment(segments[0])) {
      const first = segments.shift()!;
      const text = first.text;

      const willPrint = segments.some(seg => isWordSeg(seg));
      didWrote = willPrint;

      if (segments.length === 0) {
        sourceNode.add([
          this.indention,
          'w.result += ',
          JSON.stringify(text + '\n'),
          ';\n'
        ]);
        return sourceNode;
      }

      const [prefix, rest] = splitLeadingBlank(text);

      didWrote = didWrote || !!rest;

      if (prefix && rest) {
        sourceNode.add(
          this.text(first, [
            this.indention,
            'w.indent(' + JSON.stringify(prefix) + ');\n',
            this.indention,
            'w.write(' + JSON.stringify(rest) + ');\n'
          ])
        );
      } else if (rest) {
        sourceNode.add(
          this.text(first, [
            this.indention,
            'w.write(' + JSON.stringify(rest) + ');\n'
          ])
        );
      } else if (willPrint) {
        sourceNode.add(
          this.text(first, [
            this.indention,
            'w.indent(' + JSON.stringify(prefix) + ');\n'
          ])
        );
      }
    } else {
      didWrote = segments.some(seg => isWordSeg(seg));
    }

    for (const segment of segments) {
      sourceNode.add(this.visit(segment));
    }

    if (didWrote) {
      sourceNode.add([this.indention, 'w.brk();\n']);
    }

    return sourceNode;
  }

  visitSpan(context: Parser.SpanContext) {
    return this.text(context, [
      this.indention,
      'w.write(' + JSON.stringify(context.text) + ');\n'
    ]);
  }

  visitPrint(context: Parser.PrintContext) {
    return this.text(context, [
      this.indention,
      'w.write(',
      this.visitChildren(context),
      ');\n'
    ]);
  }

  visitLoopBegin(context: Parser.LoopBeginContext) {
    this.controlFlowStack.push('for');
    const id = context.identifier();
    const expr = this.visit(context.expressionSequence());
    this.symbols.pushFrame();
    this.symbols.set(id.text, null);
    const indention = this.indention;
    this.indentLevel++;
    return this.text(context, [
      indention,
      'for (const _',
      this.visit(id),
      ' of ',
      expr,
      ') {\n'
    ]);
  }

  visitLoopEnd(context: Parser.LoopEndContext) {
    this.indentLevel--;
    this.pop('for');
    this.symbols.popFrame();
    return this.text(context, [this.indention, '}\n']);
  }

  visitIfBegin(context: Parser.IfBeginContext) {
    this.usedElse = false;
    this.controlFlowStack.push('if');
    const indention = this.indention;
    this.indentLevel++;
    return this.text(context, [
      indention,
      'if (',
      this.visit(context.expressionSequence()),
      ') {\n'
    ]);
  }

  visitElseCmd(context: Parser.ElseCmdContext) {
    this.check('if');
    if (this.usedElse) throw new Error('`Else` is already used.');
    this.indentLevel--;
    const indention = this.indention;
    this.indentLevel++;
    this.usedElse = true;
    return this.text(context, [indention, '} else {\n']);
  }

  visitIfEnd(context: Parser.IfEndContext) {
    this.pop('if');
    this.indentLevel--;
    return this.text(context, [this.indention, '}\n']);
  }

  // ---------------------------------------- JS Expressions
  visitExpressionSequence(node: Parser.ExpressionSequenceContext) {
    const expressions = node.singleExpression().map(child => this.visit(child));
    const source = this.text(node, [expressions.shift()!]);
    for (const expression of expressions) {
      source.add(',');
      source.add(expression);
    }
    return source;
  }

  visitMemberIndexExpression(node: Parser.MemberIndexExpressionContext) {
    return this.text(node, [
      this.visit(node.singleExpression()),
      '[',
      this.visit(node.expressionSequence()),
      ']'
    ]);
  }

  visitMemberDotExpression(node: Parser.MemberDotExpressionContext) {
    return this.text(node, [
      this.visit(node.singleExpression()),
      '.',
      this.visit(node.identifierName())
    ]);
  }

  visitArgumentsExpression(node: Parser.ArgumentsExpressionContext) {
    return this.text(node, [
      this.visit(node.singleExpression()),
      this.visit(node.arguments())
    ]);
  }

  visitArguments(node: Parser.ArgumentsContext) {
    const args = node.argument().map(child => this.visit(child));
    const source = this.text(node, '(');
    for (let i = 0; i < args.length; ++i) {
      if (i > 0) {
        source.add(',');
      }
      source.add(args[i]);
    }
    source.add(')');
    return source;
  }

  visitTypeofExpression(node: Parser.TypeofExpressionContext) {
    return this.text(node, ['typeof ', this.visit(node.singleExpression())]);
  }

  visitUnaryPlusExpression(node: Parser.UnaryPlusExpressionContext) {
    return this.text(node, ['+', this.visit(node.singleExpression())]);
  }

  visitUnaryMinusExpression(node: Parser.UnaryMinusExpressionContext) {
    return this.text(node, ['-', this.visit(node.singleExpression())]);
  }

  visitBitNotExpression(node: Parser.BitNotExpressionContext) {
    return this.text(node, ['~', this.visit(node.singleExpression())]);
  }

  visitNotExpression(node: Parser.NotExpressionContext) {
    return this.text(node, ['-', this.visit(node.singleExpression())]);
  }

  visitPowerExpression(node: Parser.PowerExpressionContext) {
    return this.text(node, [
      this.visit(node.singleExpression(0)),
      '**',
      this.visit(node.singleExpression(1))
    ]);
  }

  visitMultiplicativeExpression(node: Parser.MultiplicativeExpressionContext) {
    return this.text(node, [
      this.visit(node.singleExpression(0)),
      node.children![1].text,
      this.visit(node.singleExpression(1))
    ]);
  }

  visitAdditiveExpression(node: Parser.AdditiveExpressionContext) {
    return this.text(node, [
      this.visit(node.singleExpression(0)),
      node.children![1].text,
      this.visit(node.singleExpression(1))
    ]);
  }

  visitCoalesceExpression(node: Parser.CoalesceExpressionContext) {
    if (this.options.typescript) {
      return this.text(node, [
        this.visit(node.singleExpression(0)),
        '??',
        this.visit(node.singleExpression(1))
      ]);
    }
    return this.text(node, [
      '(tmp = (',
      this.visit(node.singleExpression(0)),
      '), (tmp !== null && tmp !== undefined) ? tmp : ',
      this.visit(node.singleExpression(1)),
      ')'
    ]);
  }

  visitBitShiftExpression(node: Parser.BitShiftExpressionContext) {
    return this.text(node, [
      this.visit(node.singleExpression(0)),
      node.children![1].text,
      this.visit(node.singleExpression(1))
    ]);
  }

  visitRelationalExpression(node: Parser.RelationalExpressionContext) {
    return this.text(node, [
      this.visit(node.singleExpression(0)),
      node.children![1].text,
      this.visit(node.singleExpression(1))
    ]);
  }

  visitInstanceofExpression(node: Parser.InstanceofExpressionContext) {
    return this.text(node, [
      this.visit(node.singleExpression(0)),
      ' instanceof ',
      this.visit(node.singleExpression(1))
    ]);
  }

  visitInExpression(node: Parser.InExpressionContext) {
    return this.text(node, [
      this.visit(node.singleExpression(0)),
      ' in ',
      this.visit(node.singleExpression(1))
    ]);
  }

  visitEqualityExpression(node: Parser.EqualityExpressionContext) {
    return this.text(node, [
      this.visit(node.singleExpression(0)),
      node.children![1].text,
      this.visit(node.singleExpression(1))
    ]);
  }

  visitBitAndExpression(node: Parser.BitAndExpressionContext) {
    return this.text(node, [
      this.visit(node.singleExpression(0)),
      '&',
      this.visit(node.singleExpression(1))
    ]);
  }

  visitBitOrExpression(node: Parser.BitOrExpressionContext) {
    return this.text(node, [
      this.visit(node.singleExpression(0)),
      '|',
      this.visit(node.singleExpression(1))
    ]);
  }

  visitLogicalAndExpression(node: Parser.LogicalAndExpressionContext) {
    return this.text(node, [
      this.visit(node.singleExpression(0)),
      '&&',
      this.visit(node.singleExpression(1))
    ]);
  }

  visitLogicalOrExpression(node: Parser.LogicalOrExpressionContext) {
    return this.text(node, [
      this.visit(node.singleExpression(0)),
      '||',
      this.visit(node.singleExpression(1))
    ]);
  }

  visitTernaryExpression(node: Parser.TernaryExpressionContext) {
    return this.text(node, [
      this.visit(node.singleExpression(0)),
      '?',
      this.visit(node.singleExpression(1)),
      ':',
      this.visit(node.singleExpression(1))
    ]);
  }

  visitIdentifierExpression(node: Parser.IdentifierExpressionContext) {
    if (this.symbols.has(node.text)) {
      return this.text(node, '_' + node.text);
    }
    return this.text(node, '$.' + node.text);
  }

  visitLiteralExpression(node: Parser.LiteralExpressionContext) {
    return this.text(node, node.text);
  }

  visitParenthesizedExpression(node: Parser.ParenthesizedExpressionContext) {
    return this.text(node, ['(' + this.visitChildren(node), ')']);
  }

  visitIdentifierName(node: Parser.IdentifierNameContext) {
    return this.text(node, node.text);
  }

  visitIdentifier(node: Parser.IdentifierContext) {
    return this.text(node, node.text);
  }

  protected text(
    node: ParserRuleContext,
    chunk: string | SourceNode | (string | SourceNode)[]
  ) {
    return new SourceNode(
      node.start.line,
      node.start.charPositionInLine,
      this.options.uri,
      chunk
    );
  }
}

function isSpanSegment(segment: Parser.SegmentContext): boolean {
  if (segment.childCount === 0) return false;
  return segment.getChild(0) instanceof Parser.SpanContext;
}

function isPrintSegment(segment: Parser.SegmentContext): boolean {
  if (segment.childCount === 0) return false;
  return segment.getChild(0) instanceof Parser.PrintContext;
}

function isPartialUseSegment(segment: Parser.SegmentContext): boolean {
  if (segment.childCount === 0) return false;
  return segment.getChild(0) instanceof Parser.PartialUseContext;
}

function isWordSeg(segment: Parser.SegmentContext): boolean {
  if (segment.childCount === 0) return false;
  return (
    isSpanSegment(segment) ||
    isPrintSegment(segment) ||
    isPartialUseSegment(segment)
  );
}
